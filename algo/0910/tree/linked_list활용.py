# linked_list의 활용

# 연결 리스트를 활용하여 stack을 구현 할 수 있다.
# 스택의 원소 : 리스트의 노드
# - 스택 내의 순서는 리스트의 링크를 통해 연결됨
# Push : 리스트의 마지막에 노드 삽입
# Pop : 리스트의 마지막 노드 반환/ 삭제

# 변수 Top
# 리스트의 마지막 노드를 가리키는 변수
# 초기 상태 : Top = None

# 리스트를 이용해 push와 pop연산 구현
# 1. None 값을 가지는 노드를 만들어 스택 초기화
# 2. 원소 A 삽입 : push(A)
# 3. 원소 B 삽입 : push(B)
# 4. 원소 C 삽입 : push(C)
# 5. 원소 반환 : pop

# push/ pop 연산의 알고리즘
def push(i):      # 원소 i를 스택 top(맨앞)위치에 push
    global top
    top = Node(i, top)    # 새로운 노드 생성

def pop():              # 스택의 top을 pop
    global top

    if top == None:    # 빈 리스트이면
        print("error")
    else:
        data = top.data
        top = top.link     # top이 가리키는 노드를 바꿈
        return data


# 우선순위 큐의 구현과 기본 연산
# 우선순위 큐의 구현 : 연결 리스트를 이용한 우선순위 큐
# 우선순위 큐의 기본 연산 : 삽입 - enQueue
#                          삭제 - deQueue

# 순차 리스트를 이용한 우선순위 큐 구현
# 순차 리스트를 이용하여 자료 저장
# 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
# 가장 앞에 최고 우선순위의 원소가 위치하게 됨
# 문제점 : 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함
#          이에 소요되는 시간이나 메모리 낭비가 큼

# 연결 리스트를 이용한 우선순위 Queue 구현
# 연결 리스트를 이용하여 자료 저장
# 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를
# 삽입하는 구조
# 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨
# 배열 대비 장점 : 삽입/ 삭제 연산 이후 원소의 재배치가 필요 없음
#                 메모리의 효율적인 사용이 가능함

