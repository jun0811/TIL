# 0826 정리



### stack

> 선형구조 자료구조 (비선형 : 트리) , 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
>
> 후입 선출 (LIFO)

---

def push(item):

​	stack.append(item) #리스트는 오버플로우 신경 x

​	

def pop():

​	if len(s) == 0 :

​		return 

​	else:

​		return stack.pop(-1) # -1 없어도 됨/

---

**C 스타일**

arr = [0] * 100;

---



동적 연결리스트를 이용하여 저장소를 동적 활당 

#### 스택의 활용 

- 괄호검사
- 함수 호출 (함수를 호출하면 함수안에서 사용되는 내장 함수, 다른 함수를 또 호출) : 가장먼저 실행되는 함수가 가장 나중에 실행



### DP (동적 계획법)

>그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
>
>먼저 입력 크기가 작은 부분 문제들을 모두 해결 -> 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결
>
>-> **최종적으로 원래 주어진 입력의 문제를 해결** 



### DFS(깊이 우선)

> 비선형 구조 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
>
> ``깊이 우선 탐색``  ,`` 너비 우선탐색`` 

- DFS 방법

  - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
  - 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아옴
  - 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문 순회
  - 후입선출 구조의 `스택`을 사용 

  **다시 돌아오기 위한 방법으로 스택을 사용했다**

`

DFS : 인접 행렬 문제풀이 

---

DFS_Recursive(G, v): # 회귀로 구현 -> 가능하지만 stack으로 구현해야 overflow 위험성을 줄일 수 있다.

​	visited[ v ] <- True // v방문 설정

​	for w in adjancency ( G, v ):  # 인접 행렬 

​		if visited [ w ] ! = True: # 안간  것만 가 

​			DFS_Recursive(G,w )

---

- stack 이용법

  

